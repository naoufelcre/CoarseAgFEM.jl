var documenterSearchIndex = {"docs":
[{"location":"index.html#CoarseAgFEM.jl","page":"Home","title":"CoarseAgFEM.jl","text":"Documentation for CoarseAgFEM.jl, a package for robust aggregation finite element methods on Quadtree meshes.","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"CoarseAgFEM\")","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"CoarseAgFEM: Robust Aggregation for Finite Element Methods.\nQuadtree Meshing: Generate Quadtree meshes from Cartesian grids.\nRobust Aggregation: Handle small cut cells with robust aggregation strategies.","category":"section"},{"location":"index.html#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"index.html#Exported-Functions","page":"Home","title":"Exported Functions","text":"generate_fine_mesh\nbottom_up_coarsening!\nclassify_leaves!\nbalance!\npave_mesh\ncartesian_to_quadtree\nquadtree_to_discrete_model\nwrite_vtk","category":"section"},{"location":"index.html#Types","page":"Home","title":"Types","text":"QuadMesh\nQuadNode\nQuadElement\nRobustAggregation","category":"section"},{"location":"index.html#CoarseAgFEM.CartesianToQuadtree.cartesian_to_quadtree-Tuple{Gridap.Geometry.CartesianDiscreteModel}","page":"Home","title":"CoarseAgFEM.CartesianToQuadtree.cartesian_to_quadtree","text":"cartesian_to_quadtree(model::CartesianDiscreteModel)\n\nConverts a Gridap CartesianDiscreteModel into a QuadMesh. The conversion is \"Bottom-Up\":\n\nInput cells become the initial \"Leaves\" of the QuadMesh.\nWe infer the tree structure (parents) based on the grid topology.\nThe resulting QuadMesh may be a \"Forest\" (multiple roots) if the domain is not a square power-of-two.\n\n\n\n\n\n","category":"method"},{"location":"index.html#CoarseAgFEM.RobustAgFEM.RobustAggregation","page":"Home","title":"CoarseAgFEM.RobustAgFEM.RobustAggregation","text":"RobustAggregation(threshold=0.5, max_iters=100)\n\nStrategy for AgFEM aggregation that allows configuring the maximum number of iterations to handle long chains of small cut elements often found in adaptive meshes.\n\n\n\n\n\n","category":"type"},{"location":"index.html#CoarseAgFEM.GridapIntegration.quadtree_to_discrete_model-Tuple{Vector{QuadElement}}","page":"Home","title":"CoarseAgFEM.GridapIntegration.quadtree_to_discrete_model","text":"quadtree_to_discrete_model(elements::Vector{QuadElement})\n\nConverts a list of QuadElement (from QuadtreeAggregations) into a Gridap.UnstructuredDiscreteModel. Handles mixed meshes (Triangles and Quadrilaterals).\n\n\n\n\n\n","category":"method"},{"location":"index.html#CoarseAgFEM.QuadtreeAggregations.Coarsening.bottom_up_coarsening!-Tuple{QuadMesh}","page":"Home","title":"CoarseAgFEM.QuadtreeAggregations.Coarsening.bottom_up_coarsening!","text":"bottom_up_coarsening!(mesh::QuadMesh; max_coarsening_factor::Int=8)\n\nGreedy packing: Merges 4 siblings if they are HOMOGENEOUS (all Interior or all Exterior). Cut cells and Mixed cells are never merged. Coarsening stops if the parent cell size would exceed max_coarsening_factor * h_min (e.g. 8*h).\n\n\n\n\n\n","category":"method"},{"location":"index.html#CoarseAgFEM.QuadtreeAggregations.Coarsening.classify_leaves!-Tuple{QuadMesh, Function}","page":"Home","title":"CoarseAgFEM.QuadtreeAggregations.Coarsening.classify_leaves!","text":"classify_leaves!(mesh::QuadMesh, level_set_func::Function; buffer_width::Float64=0.0)\n\nClassifies all active leaves as INTERIOR, EXTERIOR, CUT, or BUFFER. BUFFER status is assigned if the cell is not CUT coverage, but is within buffer_width of the interface.\n\n\n\n\n\n","category":"method"},{"location":"index.html#CoarseAgFEM.QuadtreeAggregations.Coarsening.generate_fine_to_coarse_map-Tuple{QuadMesh, Int64}","page":"Home","title":"CoarseAgFEM.QuadtreeAggregations.Coarsening.generate_fine_to_coarse_map","text":"generate_fine_to_coarse_map(mesh::QuadMesh, max_level::Int)\n\nGenerates a mapping between the uniform fine grid (at max_level) and the current coarse QuadMesh.\n\nReturns:     - finemap: Matrix{Int} of size (2^maxlevel, 2^maxlevel).        finemap[i, j] contains the ID of the Leaf Node that covers fine cell (i, j).\n\nThis serves as a mapping operator M: Ωh -> ΩH.\n\n\n\n\n\n","category":"method"}]
}
